---
layout:     post
title:      "2019 *ctf Writeup"
subtitle:  "1"
date:       2019-04-30
author:     "Ambi9u0us"
header-img: "/img/in-post/1556521616210.png"
catalog: true
tags:
    - 生活
---

# 2019  *ctf Writeup

很不幸，这次就做出了一道re的题fanoGo，简单记录一下自己做出来的经历吧

## fanoGo

首先拿过来先用IDA反汇编，发现是64位的elf，然后搜索字符串，发现了这个东西：

![1556520887958](/img/in-post/1556520887958.png)

很明显的go语言特征，说明这个elf是用go编写的，因为是linux下编译，所以保留了符号表，这样的go逆向首



先要找到main_main函数：

![1556521054438](/img/in-post/1556521054438.png)

函数主要需要注意的点，一个是会读文件corpus.txt：

![1556521616210](/img/in-post/1556521616210.png)

不过这个文件读取内容好像闭关没有度后续有什么影响，然后是nc后会有个Say something:，然后输入我们构造的一串字符，然后函数bufio_Reader_Read函数读取字符

![1556521659941](/img/in-post/1556521659941.png)

然后会将这串字符进行解密，是的，就是解密，我们构造的字符串是个密文：

![1556521718904](/img/in-post/1556521718904.png)

然后就进入到一个重要的分支：

![1556521765291](/img/in-post/1556521765291.png)

看到了好玩的./flag，所以就是要想办法让v30不等于0，这样就能读取到./flag中的内容，但是首先得进入到 v49.cap == 346这一个分支，而经过调试可以知道，解密后得到的明文长度给到了这个v49.cap，所以呢，说明解密后的铭文要是346个字节，嘿嘿，再看那一段写入内存的字符串"If you cannot read all..."，正好就是346个，嗯哼，就是你了。

但是呢，要怎么得到密文呢，不想看解密函数，然后搜索了一下，发现有个加密函数fano___Fano\_\_Enecode，所以走捷径，直接IDA修改内存16进制，看一下解密函数和加密函数这个开始地址，修改修改，将调用的函数改成Encode，然后保存得到新的elf文件fanoGo1，然后gdb调试获取加密后的字符

### 插曲

这里说个小插曲，由于我以前没用过pwntools（菜鸡实在不好意思说出口，但是确实没用过，不会），所以呢，得到加密后的字符串后我一筹莫展，因为尼玛怎么全是不可见字符，我怎么输入啊！然后一开始在试只保证解密后字符长度能不能过，然后发现是不行的，原因就在于runtime_eqstring()函数，进去之后是这样：

![1556522675208](/img/in-post/1556522675208.png)

这里面v0与v1分别是存储解密后字符串和那个硬编码字符串的地址，所以相同是不可能相同的，所以必进入runtime_memeqbody()，这个函数是这样的：

![1556522914887](/img/in-post/1556522914887.png)

这里面v1就是解密后字符串长度，前面都是各种判断长度是不是小于8，当然不是啦，所以进入主要流程，在我用gdb调试后发现这里就是对解密后字符和那串硬编码字符进行比较，相等才会最后进入LABEL_7，使v0不等于0，这个值最后会给到我们的v30，当然这里我看到好像只比较了每隔16位的字符是否相等，所以其实不一定要全部一样。



回到正题，当我终于发现pwntool能够解决我的问题的时，简直爆炸，题目全都在互相融合了么？然后写下脚本，发送到远程，获取到flag，注意这里发送的时候最好在收到Say something:之后，而且要用send不要用sendline，不然进行解密的字符串会多一个\n字符，最后captute the flag：*CTF{NUY4a3E5D9186hVzejoyItr7xHBcmOpv}

好像写得太罗嗦了，望见谅。
